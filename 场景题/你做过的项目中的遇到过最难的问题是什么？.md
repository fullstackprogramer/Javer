# 你做过的项目中的遇到过最难的问题是什么？

案例1：

@Transactional 事务注解和并发加锁，导致数据不一致。
问题描述:减库存的操作，读取库存大于等于 1,就减少库存，并且添加订单表。加入了 ReentrantLock 作为同步锁，方法使用@Transactional 注解修饰。测试发现订单表增加了多个。
解决:
1 先查看代码写的是否有问题，无。
2 然后重启编译器，无法解决。
3 这个问题，像是读取到了缓存，库存并没有超卖，仅仅订单多添加，说明锁是起作用了的。考虑是不是 mybatis 缓存和数据库缓存，关闭 mybatis 二级缓存，给查询语句加 forupdate 排它锁。依然无法解决
4 百度事物注解在并发情况下失效，复习代理模式和事物特性后了解原因，先加锁再加事务，得到解决。
原因:@Transactional 是以代理模式实现的，在线程 1 开启事务后，获得锁进行执行，'执行完毕释放锁，但此时并未提交事务。线程 2 此时获得锁，进行执行，查询到库存为 1，并且修改库存，添加订单表，进行提交，释放锁。线程 1 也提交事务，导致订单表重复添加
案例2：
解决思路就是先找到问题的根因在哪里，然后才好对症下药。
 最难解决的问题是曾经在一个项目中使用的是 mongodb 来做全文搜索，而存在 mongodb 里的文档是都是几 K 至 100 多 M 的大小，导致的问题就是压测时当用 mongodb 做搜索时，其内存会一直不停的增涨，直到耗尽整个物理内存最后宕机。为了解决这个问题几乎把 mongodb 官网的文档给查了一个遍，都没有找到解决方案，因为他就是这样设计的，那时还用的是 mongodb3.x 的版本。后来就用 cgroup 来限制 mongodb 进程的内存消耗。但仍然治标不治本，因为当内存达到限制的最大内存时仍然会宕机。最后采取用 shell 脚本定时查系统内存当达到一定的阈值清除文件系统 cache 的办法，但仍然不行。仍然解决不了问题，系统吞吐量更差了。后来就换成了 elasticsearch,因为它在满足搜索的前提下，还有堆内存自动回收。但也有会碰到当搜索出来大文档对象时，对象直接从 young 区进入 old 区而导致 oom 的问题，但相对之前 mongodb 的情况已经有了很大的改善，虽然仍然没有彻底解决大文档对象搜索导致 OOM 的问题，这就是曾经碰到的最难解决的问题。
案例3：



> 原文: <https://www.yuque.com/tulingzhouyu/db22bv/xu0ycm5ucl170rvc>